# ДЗ-2:

## Задание:

1. Открыть консоль и зайти по ssh на ВМ
2. Открыть вторую консоль и также зайти по ssh на ту же ВМ (можно в докере 2 сеанса)
3. Запустить везде psql из под пользователя postgres
4. Сделать в первой сессии новую таблицу и наполнить ее данными
5. Посмотреть текущий уровень изоляции:
6. Начать новую транзакцию в обеих сессиях с дефолтным (не меняя) уровнем
   изоляции
7. В первой сессии добавить новую запись
8. Сделать запрос на выбор всех записей во второй сессии
9. Видите ли вы новую запись и если да то почему? После задания можете сверить
   правильный ответ с эталонным (будет доступен после 3 лекции)
10. Завершить транзакцию в первом окне
11. Сделать запрос на выбор всех записей второй сессии
12. Видите ли вы новую запись и если да то почему?
13. Завершите транзакцию во второй сессии
14. Начать новые транзакции, но уже на уровне repeatable read в ОБЕИХ сессиях
15. В первой сессии добавить новую запись
16. Сделать запрос на выбор всех записей во второй сессии
17. Видите ли вы новую запись и если да то почему?
18. Завершить транзакцию в первом окне
19. Сделать запрос во выбор всех записей второй сессии
20. Видите ли вы новую запись и если да то почему?

---

## Ответ:

1. В 1-ом окне терминала `docker exec -ti postgresql_course-postgres-1 bash`
2. Во 2-ом окне терминала `docker exec -ti postgresql_course-postgres-1 bash`
3. `psql -U postgres`
4. В 1-ом окне:
```postgresql
create schema if not exists hw2;

create table if not exists hw2.test (
      id          serial,
      val         integer,
      console     integer,
      created_at  timestamp with time zone default now()
);

insert into hw2.test (val, console) values (111, 1);
insert into hw2.test (val, console) values (222, 1);
insert into hw2.test (val, console) values (333, 1);
insert into hw2.test (val, console) values (444, 1);
insert into hw2.test (val, console) values (555, 1);
```
5. В 1-ом окне: `read committed`
```bash
postgres=# show transaction isolation level;
 transaction_isolation
-----------------------
 read committed
(1 row)
```
6. Начал новую транзакцию в обеих сессиях с дефолтным уровнем изоляции `read committed`
7. В 1-ом окне новый инсерт
```bash
postgres=# begin;
BEGIN
postgres=*# insert into hw2.test (val, console) values (777, 1);
INSERT 0 1
postgres=*#
```
8. Во 2-ом окне делаю селект
```bash
postgres=# begin;
BEGIN
postgres=*# select * from hw2.test;
 id | val | console |          created_at
----+-----+---------+-------------------------------
  1 | 111 |       1 | 2024-10-05 19:18:58.907801+00
  2 | 222 |       1 | 2024-10-05 19:18:58.91187+00
  3 | 333 |       1 | 2024-10-05 19:18:58.912763+00
  4 | 444 |       1 | 2024-10-05 19:18:58.913468+00
  5 | 555 |       1 | 2024-10-05 19:18:58.91412+00
  6 | 666 |       1 | 2024-10-05 19:32:09.512273+00
(6 rows)

postgres=*#
```
9. Во 2-ом окне не вижу новую запись. Поведение транзакций с разными уровнями изоляции управляется тем, как транзакции взаимодействуют со "снимками" данных, которые они видят в базе данных. Транзакция с уровнем изоляции `read committed` не фиксирует снимок данных на момент начала транзакции = она всегда видит актуальные данные на момент каждой отдельной команды. Т.е. каждая команда (например, `select`) в транзакции видит данные, которые были зафиксированы (committed) до начала этой команды.
10. Завершаю транзакцию в 1-ом окне
```bash
postgres=*# end;
COMMIT
```
11. Во 2-ом окне снова делаю селект по всем данным таблицы
```bash
postgres=*# select * from hw2.test;
 id | val | console |          created_at
----+-----+---------+-------------------------------
  1 | 111 |       1 | 2024-10-05 19:18:58.907801+00
  2 | 222 |       1 | 2024-10-05 19:18:58.91187+00
  3 | 333 |       1 | 2024-10-05 19:18:58.912763+00
  4 | 444 |       1 | 2024-10-05 19:18:58.913468+00
  5 | 555 |       1 | 2024-10-05 19:18:58.91412+00
  6 | 666 |       1 | 2024-10-05 19:32:09.512273+00
  7 | 777 |       1 | 2024-10-05 19:35:52.941671+00
(7 rows)
```
12. Вижу новую запись, потому что в 1-ом окне закоммитил транзакцию
13. Завершил транзакцию во 2-ом окне
14. Начал новую транзакцию в обеих сессиях `begin transaction isolation level repeatable read;`
15. В 1-ом окне:
```bash
postgres=# begin transaction isolation level repeatable read;
BEGIN
postgres=*# insert into hw2.test (val, console) values (888, 1);
INSERT 0 1
postgres=*#
```
16. Во 2-ом окне:
```bash
postgres=# begin transaction isolation level repeatable read;
BEGIN
postgres=*# select * from hw2.test;
 id | val | console |          created_at
----+-----+---------+-------------------------------
  1 | 111 |       1 | 2024-10-05 19:18:58.907801+00
  2 | 222 |       1 | 2024-10-05 19:18:58.91187+00
  3 | 333 |       1 | 2024-10-05 19:18:58.912763+00
  4 | 444 |       1 | 2024-10-05 19:18:58.913468+00
  5 | 555 |       1 | 2024-10-05 19:18:58.91412+00
  6 | 666 |       1 | 2024-10-05 19:32:09.512273+00
  7 | 777 |       1 | 2024-10-05 19:35:52.941671+00
(7 rows)

postgres=*#
```
17. Не вижу новую запись, потому что на этом этапе я не зафиксировал (commit) данные. Такая же ситуация как с уровнем `read committed`.
18. В 1-ом окне завершил транзакцию
```bash
postgres=*# end;
COMMIT
postgres=#
```
19. Во 2-ом окне:
```bash
postgres=*# select * from hw2.test;
 id | val | console |          created_at
----+-----+---------+-------------------------------
  1 | 111 |       1 | 2024-10-05 19:18:58.907801+00
  2 | 222 |       1 | 2024-10-05 19:18:58.91187+00
  3 | 333 |       1 | 2024-10-05 19:18:58.912763+00
  4 | 444 |       1 | 2024-10-05 19:18:58.913468+00
  5 | 555 |       1 | 2024-10-05 19:18:58.91412+00
  6 | 666 |       1 | 2024-10-05 19:32:09.512273+00
  7 | 777 |       1 | 2024-10-05 19:35:52.941671+00
(7 rows)
```
20. Всё ещё не вижу запись, потому что на уровне изоляции `repeatable read` транзакция фиксирует "снимок" данных на момент начала транзакции и использует его на протяжении всего времени выполнения. Все команды внутри транзакции будут видеть одно и то же состояние данных, даже если в другой транзакции произошли изменения и данные были зафиксированы (committed). Только после завершения транзакции во 2-ом окне можно увидеть новую запись.
```bash
postgres=*# end;
COMMIT
postgres=# select * from hw2.test;
 id | val | console |          created_at
----+-----+---------+-------------------------------
  1 | 111 |       1 | 2024-10-05 19:18:58.907801+00
  2 | 222 |       1 | 2024-10-05 19:18:58.91187+00
  3 | 333 |       1 | 2024-10-05 19:18:58.912763+00
  4 | 444 |       1 | 2024-10-05 19:18:58.913468+00
  5 | 555 |       1 | 2024-10-05 19:18:58.91412+00
  6 | 666 |       1 | 2024-10-05 19:32:09.512273+00
  7 | 777 |       1 | 2024-10-05 19:35:52.941671+00
  8 | 888 |       1 | 2024-10-05 19:48:05.465556+00
(8 rows)

postgres=#
```


## Итог 

- С `read committed` транзакция видит зафиксированные изменения, выполненные другими транзакциями до каждого запроса
- С `repeatable read` транзакция видит одно и то же состояние данных на протяжении всего своего выполнения, игнорируя любые изменения, произошедшие после её начала.